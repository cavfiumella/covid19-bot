#!/usr/bin/env python3.9

"""Admin console for Telegram BOT defined in helpers.bot module.

Available options can be printed calling
    ./console [-h|--help]

Available console commands can be printed after starting with (h | help).
"""


from _version import get_version
from helpers.database import BaseDatabase, Contagions, Vaccines
from helpers.bot import MyBot
from helpers.report import Reporter

from argparse import ArgumentParser
import logging
from traceback import format_exc
import sys
from typing import Dict, Optional, Any
from pathlib import Path
import pickle as pkl
import json


def print_console_help(commands: Dict[str,str], /) -> None:
    """Prints console commands available and their descriptions.

    Parameters:
    - commands: commands and their description
    """

    print("Available commands:")

    for cmd, desc in commands.items():
        print("\t" + cmd + " " + "." * (48-len(cmd)) + " " + desc)


def start(
    db: Dict[str, BaseDatabase], mybot: Optional[MyBot] = None,
    token: Optional[str] = None, reporter: Optional[Reporter] = None,
    idle: bool = True, test: bool = False
) -> (MyBot, str, Reporter):
    """Start bot and reporter.

    Parameters:
    - db: databases objects as a dict (i.e. {key: db})
    - mybot: Telegram bot to starts, if None a new one is created
    - token: Telegram API token
    - reporter: Reporter object to use, if None a new one is created
    - idle: keeps main thread until bot receive a signal to stop
    - test: run in test mode

    Returns:
    updated mybot, token and reporter.
    If idle is True mybot and reported are stopped, otherwise returned objects
    are running
    """

    if token == None:
        token = input("Token: ")

    if test:
        # ignore mybot and reporter arguments
        mybot = MyBot(token, db=db, persistence=False)
        reporter = Reporter(mybot, db=db)
    else:
        if mybot == None:
            mybot = MyBot(token, db=db)
        if reporter == None:
            reporter = Reporter(mybot, db=db)

    mybot.start()
    reporter.start()

    if idle:
        mybot.idle() # wait signal that stops bot
        reporter.stop()

    return mybot, token, reporter


def read_persistence(path: Path) -> dict:
    """Read persistence from file.

    Parameters:
    - path: path to bot's persistence file

    Returns:
    data read from persistence file
    """

    with path.open("rb") as file:
        data = pkl.load(file)

    return data


def write_persistence(obj: Any, path: Path) -> None:
    """Write object on pickle file.

    Parameters:
    - obj: object to write
    - path: path to pickle file
    """

    with path.open("wb") as file:
        pkl.dump(obj, file)


def console(cmd: Optional[str] = None, token: Optional[str] = None) -> int:
    """Parameters:
    - cmd: first command to use, if None prompt input
    - token: Telegram API token, if None will be requested when needed

    Returns:
    exit code
    """

    commands = {
        "h|help": "prints help message",
        "s|start": "start bot",
        "T|test": "start bot in test mode",
        "A|announce": "send an announce to all users",
        "r|read <path>": "read bot's presistence file",
        "N|new <path> <data to edit> <id>": "insert new data in persistence "
                                            "file (DANGER ZONE)",
        "D|delete <path> <data to edit> <id>": "delete data from persistence "
                                               "file (DANGER ZONE)",
        "E|edit <path> <data to edit> <id>": "edit data in persistence file "
                                             "(DANGER ZONE)",
        "X|exec": "execute Python code (DANGER ZONE)",
        "q|quit": "quit"
    }

    db = {
        key: eval(f"{key.capitalize()}()")
        for key in ["contagions", "vaccines"]
    }

    mybot: MyBot = None
    reporter: Reporter = None

    while True:

        if cmd == None:
            cmd = input("\nCommand: ")

        # parse cmd
        cmd = cmd.split()

        # catch uncaught exceptions
        try:

            if cmd[0] in ["help", "h"]:
                print_console_help(commands)

            elif cmd[0] in ["start", "s"]:
                print("Running bot...")
                mybot, token, reporter = start(db, mybot, token, reporter)

            elif cmd[0] in ["test", "T"]:
                print("Running bot in test mode...")
                start(db, mybot, token, reporter, test=True)

            elif cmd[0] in ["announce", "A"]:
                mybot, token, reporter = start(
                    db, mybot, token, reporter, idle=False
                )

                parse_mode = input("\nParse mode: ")
                text = input("Text: ")

                print(f"\nParse mode: {parse_mode}")
                print(f"Text: \n{text}")

                confirm = input("\nSend announcement? (y/N): ")

                if confirm in ["y", "Y", "yes"]:
                    for chat_id in mybot.get_chat_data().keys():
                        mybot.send_message(
                            chat_id, parse_mode=parse_mode, text=text
                        )
                    print("Announce sent.")
                else:
                    print("Operation cancelled.")

                reporter.stop()
                mybot.stop()

            elif cmd[0] in ["read", "r"]:
                path = Path(cmd[1])
                data = read_persistence(path)
                print(json.dumps(data, indent=4))

            elif cmd[0] in ["new", "N"]:
                path = Path(cmd[1])
                data = read_persistence(path)
                data_to_edit = cmd[2]

                if data_to_edit not in data:
                    raise KeyError(data_to_edit)

                id = input("\nKey: ")
                value = eval(input("Value: "))

                data[data_to_edit].update({id: value})

                print("\nNew data:")
                print(f"{id}: {value}")

                confirm = input("\nSave changes? (y/N): ")

                if confirm in ["y", "Y", "yes"]:
                    write_persistence(data, path)
                    print("Changes saved.")
                else:
                    print("Changes dismissed.")

            elif cmd[0] in ["delete", "D"]:
                path = Path(cmd[1])
                data = read_persistence(path)
                data_to_edit = cmd[2]
                id = int(cmd[3])

                if data_to_edit not in data:
                    raise KeyError(data_to_edit)

                if id not in data[data_to_edit]:
                    raise KeyError(id)

                print(f"\nDeleted data:")
                print(data[data_to_edit].pop(id))

                confirm = input("\nSave changes? (y/N): ")

                if confirm in ["y", "Y", "yes"]:
                    write_persistence(data, path)
                    print("Changes saved.")
                else:
                    print("Changes dismissed.")

            elif cmd[0] in ["edit", "E"]:
                path = Path(cmd[1])
                data = read_persistence(path)
                data_to_edit = cmd[2]
                id = int(cmd[3])

                if data_to_edit not in data:
                    raise KeyError(data_to_edit)

                if id not in data[data_to_edit]:
                    raise KeyError(id)

                print(f"\n{data_to_edit}[{id}]:")
                print(json.dumps(data[data_to_edit][id], indent=4))

                while True:
                    key = input("\nKey: ")
                    if key == "":
                        break
                    data[data_to_edit][id].update(
                        {key: eval(input(f"Value: "))}
                    )

                print("\nEdited data:")
                print(json.dumps(data[data_to_edit][id], indent=4))

                confirm = input("\nSave changes? (y/N): ")

                if confirm in ["y", "Y", "yes"]:
                    write_persistence(data, path)
                    print("Changes saved.")
                else:
                    print("Changes dismissed.")

            elif cmd[0] in ["exec", "X"]:
                exec(input("Code: "))

            elif cmd[0] in ["quit", "q"]:
                return 0

            else:
                print("Command not recognized.", file=sys.stderr)
                print()
                print_console_help(commands)

        except:
            print("Uncaught exception:", file=sys.stderr)
            print(format_exc(), file=sys.stderr)

        # reset cmd
        cmd = None


if __name__ == "__main__":

    parser = ArgumentParser()

    # options
    parser.add_argument(
        "-s", "--start", action="store_true",
        help="Start bot without prompting console"
    )
    parser.add_argument(
        "-T", "--test", action="store_true",
        help="Start bot in test mode without prompting console"
    )
    parser.add_argument("-t", "--token", type=str, help="Telegram API token")
    parser.add_argument("-d", "--debug", action="store_true")
    parser.add_argument("-v", "--version", action="store_true")

    args = parser.parse_args()
    log_level = logging.INFO
    cmd = None

    if args.debug:
        log_level = logging.DEBUG

    logging.basicConfig(
        format="%(asctime)s %(name)s: %(message)s", level=log_level
    )

    if args.start:
        cmd = "start"

    if args.test:
        cmd = "test"

    if args.version:
        print(f"Version {get_version()}")
        sys.exit()

    sys.exit(console(cmd, args.token))
